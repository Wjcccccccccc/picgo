[toc]

#### 1.需求

1. 匹配机制
   1. 发起匹配
   2. 接收匹配
   3. 下发匹配成功
   4. 下发匹配失败
   5. 下发匹配进行中数据,心跳
   6. 下发匹配结果

2. 直播间送礼(pk送礼)

3. 首页直播间,搜索栏pk标签
4. pk
   1. 流程
      1. 匹配成功/用户接收pk邀请,开始pk,初始化pk数据.
      
         1. 同步写库,插入一条pk数据.
         2. 同步写redis.
         3. 创建定时推送pk状态的任务,和定点结束pk的任务.
         4. ws广播pk开局信息.
         5. 返回.
      
      2. pk中每5s下发一次当前的pk状态数据.
      
         1. 推送当前redis中缓存的pk数据.
      
      3. 用户进入房间,客户端ws请求房间pk状态和数据,服务端ws返回.
      
      4. pk中用户送礼.
      
         1. 刷新redis缓存数据,总礼物信息和每个用户送礼信息.
         2. 数据变化,推送一次pk当前数据(避免送礼过多导致推送过多,这里加入冷却机制,时长1s).
         3. 异步同步送礼数据到mysql.
      
      5. 到达pk时长后,定时任务自动结束pk.
      
         1. 取消定时推送pk状态的任务.
         2. 修改pk状态,同步到redis中.
         
         3. 校验redis与mysql数据是否一致,不一致则同步redis数据到mysql,保证最终一致.
         4. 推送pk结束消息到客户端.
   
5. 注意点
   1. 服务器升级,需预留开关停止匹配,和开始pk.
   2. ws断线,可能会连不上来.



#### 2.配置

1. t_config

```
INSERT INTO t_config(`name`,`value`,`desc`)
VALUES
('pk_enable','true','The switch for PK function'),
('pk_duration','1500,300000,0','pk时间控制,以逗号分隔,依次为:pk开场时间,持续时间,结束阶段时间,rtmToken有效期 mills'),
('pk_config',"{'name':'匹配赛','interveningTime':10000,'endTime':30000,'inviteNum':10,'inviteColdDown':5000}",'pk匹配相关参数'),
('pk_filter_country',"{'IN':['PK'],'PK':['IN']}",'pk匹配国家屏蔽控制'),
('version_control',"{pk:[{'vc':207,'p':'android'}]}",'各个业务版本控制')
;
```



#### 3.设计

1. redis

```
# 某一局pk的全部业务数据,hash结构
pk_${pkId}

# 所有处于pk中的房间记录,hash结构
pkr

# 全部pk匹配中用户的业务数据,hash结构
pkm ${pkId}

# 接收过pk邀请的用户记录(用于邀请冷却) sorted set结构
room_pk_invited

# 某一局pk的某个主播的收礼数据,sorted set结构
pkg_${pkId}_${userId}
```

2. mysql

```
DROP TABLE t_pk ;
CREATE TABLE t_pk(
`id` INT(11) PRIMARY KEY AUTO_INCREMENT,
`type` TINYINT(2) DEFAULT 1 COMMENT '类型: 1.双人对手房间pk',
`status` TINYINT(2) DEFAULT 1 COMMENT '状态: 1.进行中,2.正常结束,3.异常结束,4.结束后阶段',
`sequel_type` TINYINT(2) DEFAULT 1 COMMENT '类型: 0.无下阶段',
`sequel_content` VARCHAR(128) DEFAULT NULL COMMENT '下阶段内容',
`interfered` TINYINT(1) DEFAULT 1 COMMENT '是否被干预: 0.无干预,1.系统干预',

`start_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
`end_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
`duration` INT(11) DEFAULT 0 COMMENT 'pk时长',

`source_user` INT(11) NOT NULL COMMENT '发起pk用户id',
`source_toom` INT(11) NOT NULL COMMENT '发起pk用户room',
`source_gifts` INT(11) NOT NULL DEFAULT 0 COMMENT '发起pk用户收到的礼物beans值',
`source_audience` INT(11) NOT NULL DEFAULT 0 COMMENT '发起pk用户的观众数',

`target_user` INT(11) NOT NULL COMMENT '接收pk用户id',
`target_room` INT(11) NOT NULL COMMENT '接收pk用户room',
`target_gifts` INT(11) NOT NULL DEFAULT 0 COMMENT '接收pk用户收到的礼物beans值',
`target_audience` INT(11) NOT NULL DEFAULT 0 COMMENT '接收pk用户的观众数',

`winner` INT(11) NOT NULL DEFAULT 0 COMMENT '胜者',
`extend` TEXT DEFAULT NULL COMMENT '扩展内容',

`create_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
`update_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
`deleted` TINYINT(1) DEFAULT '0' COMMENT '删除标记',
`version` TINYINT(4) DEFAULT '0' COMMENT '版本',
`project_code` VARCHAR(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品编码(oyetalk、)',
`tenant_code` VARCHAR(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '租户编码',
KEY `date_source`(`create_time`,`source_user`),
KEY `date_target`(`create_time`,`target_user`),
KEY source_target_date(`source_user`,`target_user`,`create_time`)
);


DROP TABLE t_pk_gift;
CREATE TABLE t_pk_gift(
`id` INT(11) PRIMARY KEY AUTO_INCREMENT,

`pk_id` INT(11) NOT NULL COMMENT 'pkid',
`sender` INT(11) NOT NULL COMMENT '送礼用户id',

`gift_beans` INT(11) DEFAULT 0 COMMENT '送礼beans',
`gift_times` INT(11) DEFAULT 0 COMMENT '送礼次数',
`rank` INT(4) DEFAULT -1 COMMENT '当前pk场次送礼排名',
`extend` TEXT DEFAULT NULL COMMENT '扩展内容',

`create_time` DATETIME DEFAULT NULL COMMENT 'pk送礼时间',
`update_time` DATETIME DEFAULT NULL COMMENT 'pk送礼更新时间',
`deleted` TINYINT(1) DEFAULT '0' COMMENT '删除标记',
`version` TINYINT(4) DEFAULT '0' COMMENT '版本',
`project_code` VARCHAR(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品编码(oyetalk、)',
`tenant_code` VARCHAR(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '租户编码',
UNIQUE KEY pk_sender(`pk_id`,`sender`),
KEY date_pk_sender(`create_time`,`sender`)
);



DROP TABLE t_pk_anchor ;
CREATE TABLE t_pk_anchor(
`id` INT(11) PRIMARY KEY AUTO_INCREMENT,
`pk_id` INT(11) NOT NULL COMMENT 'pkid',

`duration` INT(11) DEFAULT 0 COMMENT 'pk时长',

`user_id` INT(11) NOT NULL COMMENT '主播',
`gifts` INT(11) COMMENT '收到的礼物beans值',
`audience` INT(11)  COMMENT '观众数',
`most_present_audience` INT(11) COMMENT '送礼最多观众',

`competitor` INT(11) NOT NULL COMMENT '对手用户id',
`competitor_gifts` INT(11) COMMENT '对手收到的礼物beans值',
`competitor_audience` INT(11) COMMENT '接收pk用户的观众数',

`result` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '0平局,1胜利,2失败',
`extend` TEXT DEFAULT NULL COMMENT '扩展内容',

`create_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
`update_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
`deleted` TINYINT(1) DEFAULT '0' COMMENT '删除标记',
`version` TINYINT(4) DEFAULT '0' COMMENT '版本',
`project_code` VARCHAR(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品编码(oyetalk、)',
`tenant_code` VARCHAR(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '租户编码',
KEY `user_date`(`user_id`,`create_time`)
);
```

3. 接口

   1. app内pk记录

   > http://121.37.214.86:9090/project/51/interface/api/3773

#### 4.Websocet协议定义

1. **pk状态心跳包**

> 客户端无主动请求,全是服务端推送
>
> pub类型,type为10

**推送示例**

> source代表发起匹配者,target代表接收者或者后匹配到者
>
> status为pk状态
>      //未开始
>      none(0),
>      //进行中
>      ing(1),
>      //正常结束
>      done(2),
>      //异常结束
>      error(3),

```
{
  "roomId": 2099934,
  "destination": null,
  "costTime": [],
  "msgType": "pub",
  "fromUser": -1,
  "toUser": -1,
  "mode": "m",
  "type": 10,
  "content": {
    "pkId": 19,
    "type": 1,
    "status": 1,
    "startTime": 1625811819212,
    "endTime": 1625811879212,
    "remainingTime": 4311,
    "sequelType": 0,
    "sourceUser": 2099955,
    "sourceRoom": 2099955,
    "sourceGifts": 1000,
    "sourceOnline": false,
    "sourceTopGifts": [
      {
        "consume": 1000,
        "user": {
          "id": 2100216,
          "agency": null,
          "crest": null,
          "nickname": "hello world",
          "headimg": "1607997789588.jpg",
          "level": 14,
          "roomlevel": 1,
          "vip": 0,
          "area": null,
          "sex": 2,
          "tags": null
        }
      }
    ],
    "targetUser": 2099934,
    "targetRoom": 2099934,
    "targetGifts": 0,
    "targetOnline": false,
    "targetTopGifts": []
  },
  "version": 1625811875201
}
```

2. **匹配相关请求与返回**

> command类型,commandId为28,回程commandId为-28

**请求示例**

> type=1时,开始匹配,source开始者
>
> type=2时,接收匹配,source为发出邀请者,target为接收邀请者
>
> type=3时,拒绝匹配,source为发出邀请者,target为拒绝邀请者
>
> type=4时,停止匹配,source为停止者
>
> type 类型定义
>      start(1),
>      accept(2),
>      refuse(3),
>      stop(4),

```
{
  "commandId": 28,
  "costTime": [],
  "initTime": 1626146346120,
  "logId": "socket_2__28",
  "msgType": "command",
  "roomId": 2,
  "secondInitTime": 1626146346120,
  "sequence": 0,
  "source": 2,
  "target": 1,
  "type": 1
}
```

**响应码**

```
902004: 匹配成功,随后就会下发pk开始的心跳包
902003: pk邀请已被其他人接收
905033: 主播当前已有一场pk未结束,无法开启pk
```

3. **匹配超时2分钟后,系统干预发送邀请消息**

> pub类型,type为12

**推送示例**

```json
{
  "roomId": 2099934,
  "destination": null,
  "costTime": [],
  "msgType": "pub",
  "fromUser": -1,
  "toUser": -1,
  "mode": "u",
  "type": 12,
  "content": {
    "source": 2100216
  },
  "version": 1625811875201
}
```

4. **主播开启pk匹配时,推送pk开始匹配报文.**

> pub类型,type为13
>
> 主播开启pk匹配时,若没有立即匹配成功,进入到匹配队列时,推送pk开始匹配报文.若立即匹配成功,则不推送.
>
> pk处于匹配中时,用户点击上麦,推送该报文.

**推送示例**

```json
{
  "roomId": 2099934,
  "destination": null,
  "costTime": [],
  "msgType": "pub",
  "fromUser": -1,
  "toUser": -1,
  "mode": "u",
  "type": 13,
  "content": {
    "msg": 2100216
  },
  "version": 1625811875201
}
```

5. **获取RTM token协议**

> command类型,commandId为27

**请求示例**

```
{"sequence":3,"commandId":27,"msgType":"command","roomId":2100216,"fromUser":2100216,"toUser":2100216,"mode":"u","destination":"/room/2100216"}
```

**响应示例**

```
{"roomId":2100216,"destination":"/room/2100216","costTime":[3],"msgType":"command","fromUser":2100216,"toUser":2100216,"mode":"u","sequence":3,"commandId":-27,"code":"000000","desc":"Success!","result":"005AQAoADdEOEI5MkZBM0Y1OTJCNDVDNUNCQTkzRDU4RUNBQzRDNjBDQjI5MkMQAEcB/G2Rkk4nkb6anPCN/wytF+xglLKWKAAAAAAAAA=="}
```



5. **首页展示**

   1. Related -> Recently

   ```
   /um/queryconcern
   ```

   2. Related -> Following

   ```
   /um/queryconcern
   ```

   3. Popular / You may like

   ```
   /rank/popular
   ```

   4. Explore -> New Talents

   ```
   /rank/label
   ```

   

   

#### 5.评审

###### 1.匹配

代码入口位于com/jato/video/comet/queue/process/PkProcess

实体逻辑处理位于com/jato/video/dao/po/PKMatch

redis订阅消息位于com/jato/video/linked/notify/PKMatchNotify

**功能点:**

1. 多人同时开始匹配,位于匹配队列中的用户需要做并发控制,不能被匹配到多次.
2. 多人同时接收邀请,只能有一人成功.

**设计思路:**

**匹配**

1. 用户发起匹配,服务器初始化用户匹配数据.
2. 同时拉取redis中已存在的匹配列表,开始匹配.
3. 匹配成功,发布redis消息,告知所有服务器取消双方的定时任务.
4. 匹配失败,加入到redis队列,等待其他人加入进行匹配.

**取消匹配**

1. 取消匹配者的定时任务

**接收邀请**

1. redis广播接收邀请,所有收到邀请的服务器都需要取消定时任务.
2. 只能一人接收成功.

**拒绝邀请**

1. redis广播拒绝邀请,所有收到的服务器处理拒绝逻辑.
2. 被拒绝者更新已发送邀请人的处理状态,若全部拒绝,则再次发送邀请.
3. 发送邀请采用zset存储,时间当作score,用于判断是否过了发送冷却期.



###### 2.PK

代码入口位于com/jato/video/room/service/PKService

1. 初始化pk信息,开启定时结束pk和定时推送pk数据等任务.
2. 送礼时,判断是否为pk中的送礼,并且同步写redis,异步更新数据库.
3. 推送时处理闭麦及`rtm token`等信息.
4. 推送加入冷却机制,避免过于频繁.
5. 结束pk时,处理pk定时任务,写入汇总数据,校验数据库与redis是否一致,最终一致性以redis数据为准.



###### 3.兜底

避免pk过程中,或者匹配过程中服务器挂掉导致redis中的脏数据,于是在`com/jato/video/room/service/RoomSessionManage.java`的定时扫描任务中,添加扫描过期数据机制.



#### 6.上线 

1. zookeeper 集群版(**需修改为线上配置**)

```
# 多节点部署,需要修改环境变量中的ip为现网ip
-----

docker run -d --name zookeeper -e ZOO_LOG4J_PROP="INFO,ROLLINGFILE" -e ZOO_MY_ID=1 -e ZOO_SERVERS="server.1=0.0.0.0:2888:3888;2181 server.2=192.168.10.111:2888:3888;2181 server.3=192.168.10.112:2888:3888;2181" -v /data/zookeeper/data:/data -v /data/zookeeper/logs:/logs -p 2181:2181 -p 2888:2888 -p 3888:3888 --restart always zookeeper:3.7.0

docker run -d --name zookeeper -e ZOO_LOG4J_PROP="INFO,ROLLINGFILE" -e ZOO_MY_ID=2 -e ZOO_SERVERS="server.1=192.168.10.110:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=192.168.10.112:2888:3888;2181" -v /data/zookeeper/data:/data -v /data/zookeeper/logs:/logs -p 2181:2181 -p 2888:2888 -p 3888:3888 --restart always zookeeper:3.7.0

docker run -d --name zookeeper -e ZOO_LOG4J_PROP="INFO,ROLLINGFILE" -e ZOO_MY_ID=3 -e ZOO_SERVERS="server.1=192.168.10.110:2888:3888;2181 server.2=192.168.10.111:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181" -v /data/zookeeper/data:/data -v /data/zookeeper/logs:/logs -p 2181:2181 -p 2888:2888 -p 3888:3888 --restart always zookeeper:3.7.0

```

2. nacos(**需修改为线上配置**)

```
# 新建 elasticjob.yaml, 以下为内容

elasticjob:
  reg-center:
    serverLists: 192.168.10.110:2181,192.168.10.111:2181,192.168.10.112:2181
    namespace: ${spring.application.name}_${spring.profiles.active}
    max-sleep-time-milliseconds: 10000
    session-timeout-milliseconds: 5000
  tracing:
    datasource:
      url: jdbc:mysql://192.168.10.110:3306/elasticjob?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=UTC&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: root
      password: Huawei123
```

3. mysql

   1. elasticjob任务监控数据库

      ```
      CREATE DATABASE `elasticjob`;
      ```

   2. pk数据表

      ```
      CREATE TABLE t_pk(
      `id` INT(11) PRIMARY KEY AUTO_INCREMENT,
      `type` TINYINT(2) DEFAULT 1 COMMENT '类型: 1.双人对手房间pk',
      `status` TINYINT(2) DEFAULT 1 COMMENT '状态: 1.进行中,2.正常结束,3.异常结束,4.结束后阶段',
      `sequel_type` TINYINT(2) DEFAULT 1 COMMENT '类型: 0.无下阶段',
      `sequel_content` VARCHAR(128) DEFAULT NULL COMMENT '下阶段内容',
      `interfered` TINYINT(1) DEFAULT 1 COMMENT '是否被干预: 0.无干预,1.系统干预',
      
      `start_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
      `end_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
      `duration` INT(11) DEFAULT 0 COMMENT 'pk时长',
      
      `source_user` INT(11) NOT NULL COMMENT '发起pk用户id',
      `source_toom` INT(11) NOT NULL COMMENT '发起pk用户room',
      `source_gifts` INT(11) NOT NULL DEFAULT 0 COMMENT '发起pk用户收到的礼物beans值',
      `source_audience` INT(11) NOT NULL DEFAULT 0 COMMENT '发起pk用户的观众数',
      
      `target_user` INT(11) NOT NULL COMMENT '接收pk用户id',
      `target_room` INT(11) NOT NULL COMMENT '接收pk用户room',
      `target_gifts` INT(11) NOT NULL DEFAULT 0 COMMENT '接收pk用户收到的礼物beans值',
      `target_audience` INT(11) NOT NULL DEFAULT 0 COMMENT '接收pk用户的观众数',
      
      `winner` INT(11) NOT NULL DEFAULT 0 COMMENT '胜者',
      `extend` TEXT DEFAULT NULL COMMENT '扩展内容',
      
      `create_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
      `update_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
      `deleted` TINYINT(1) DEFAULT '0' COMMENT '删除标记',
      `version` TINYINT(4) DEFAULT '0' COMMENT '版本',
      `project_code` VARCHAR(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品编码(oyetalk、)',
      `tenant_code` VARCHAR(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '租户编码',
      KEY `date_source`(`create_time`,`source_user`),
      KEY `date_target`(`create_time`,`target_user`),
      KEY source_target_date(`source_user`,`target_user`,`create_time`)
      );
      
      ```

   3. pk礼物数据表

      ```
      CREATE TABLE t_pk_gift(
      `id` INT(11) PRIMARY KEY AUTO_INCREMENT,
      
      `pk_id` INT(11) NOT NULL COMMENT 'pkid',
      `sender` INT(11) NOT NULL COMMENT '送礼用户id',
      
      `gift_beans` INT(11) DEFAULT 0 COMMENT '送礼beans',
      `gift_times` INT(11) DEFAULT 0 COMMENT '送礼次数',
      `rank` INT(4) DEFAULT -1 COMMENT '当前pk场次送礼排名',
      `extend` TEXT DEFAULT NULL COMMENT '扩展内容',
      
      `create_time` DATETIME DEFAULT NULL COMMENT 'pk送礼时间',
      `update_time` DATETIME DEFAULT NULL COMMENT 'pk送礼更新时间',
      `deleted` TINYINT(1) DEFAULT '0' COMMENT '删除标记',
      `version` TINYINT(4) DEFAULT '0' COMMENT '版本',
      `project_code` VARCHAR(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品编码(oyetalk、)',
      `tenant_code` VARCHAR(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '租户编码',
      UNIQUE KEY pk_sender(`pk_id`,`sender`),
      KEY date_pk_sender(`create_time`,`sender`)
      );
      
      ```

      

   4. pk主播数据表

      ```
      CREATE TABLE t_pk_anchor(
      `id` INT(11) PRIMARY KEY AUTO_INCREMENT,
      `pk_id` INT(11) NOT NULL COMMENT 'pkid',
      
      `duration` INT(11) DEFAULT 0 COMMENT 'pk时长',
      
      `user_id` INT(11) NOT NULL COMMENT '主播',
      `gifts` INT(11) COMMENT '收到的礼物beans值',
      `audience` INT(11)  COMMENT '观众数',
      `most_present_audience` INT(11) COMMENT '送礼最多观众',
      
      `competitor` INT(11) NOT NULL COMMENT '对手用户id',
      `competitor_gifts` INT(11) COMMENT '对手收到的礼物beans值',
      `competitor_audience` INT(11) COMMENT '接收pk用户的观众数',
      
      `result` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '0平局,1胜利,2失败',
      `extend` TEXT DEFAULT NULL COMMENT '扩展内容',
      
      `create_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
      `update_time` DATETIME DEFAULT NULL COMMENT 'pk数据创建时间',
      `deleted` TINYINT(1) DEFAULT '0' COMMENT '删除标记',
      `version` TINYINT(4) DEFAULT '0' COMMENT '版本',
      `project_code` VARCHAR(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品编码(oyetalk、)',
      `tenant_code` VARCHAR(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '租户编码',
      KEY `user_date`(`user_id`,`create_time`)
      );
      ```

   5. pk配置

      ```
      INSERT INTO t_config(`name`,`value`,`desc`)
      VALUES
      ('pk_enable','true','The switch for PK function'),
      ('pk_duration','1500,300000,0,600000','pk时间控制,以逗号分隔,依次为:pk开场时间,持续时间,结束阶段时间,rtmToken有效期 mills'),
      ('pk_config',"{'name':'匹配赛','interveningTime':120000,'endTime':600000,'inviteNum':10,'inviteColdDown':1800000}",'pk匹配相关参数'),
      ('pk_filter_country',"{'IN':['PK'],'PK':['IN']}",'pk匹配国家屏蔽控制'),
      ('version_control',"{update:[{'vc':1,'p':'android'},{'vc':1,'p':'ios'}],kickout:[{'vc':209,'p':'android'},{'vc':172,'p':'ios'}]}",'各个业务版本控制')
      ;
      ```

4. 代码

   1. quick-parent(dev分支 )
   2. quick-extend(2.3.0分支)
   3. voice-cluster(2.3.0分支)



#### 7.代码讲解

> 流程图

![](https://raw.githubusercontent.com/Wjcccccccccc/picgo/ybd/img/pk.png)

###### 1.匹配

1. 匹配采取被动匹配策略,当有用户发起匹配时,就将该用户与匹配队列中的用户进行匹配.

2. 匹配成功后,需要删除掉redis中的对手信息,才确定为匹配成功,防止并发时一个用户被多次匹配.

###### 2.PK

1. pk开局,结束信息使用redis publish到所有socket节点,用以开启或者结束elasticjob任务.
2. 防止elasticjob调度结束pk时,程序正好crash,所有加入pk状态扫描,扫描redis中pk时间已过,但没有正常结束的pk,进行结算.



#### 8.Elasticjob-lite

> [定位为轻量级无中心化解决方案,使用 jar 的形式提供分布式任务的协调服务.](https://shardingsphere.apache.org/elasticjob/current/cn/quick-start/elasticjob-lite/)

![ElasticJob-Lite Architecture](https://shardingsphere.apache.org/elasticjob/current/img/architecture/elasticjob_lite.png)

**1.功能列表**

- 弹性调度
  - 支持任务在分布式场景下的分片和高可用
  - 能够水平扩展任务的吞吐量和执行效率
  - 任务处理能力随资源配备弹性伸缩
- 资源分配
  - 在适合的时间将适合的资源分配给任务并使其生效
  - 相同任务聚合至相同的执行器统一处理
  - 动态调配追加资源至新分配的任务
- 作业治理
  - 失效转移
  - 错过作业重新执行
  - 自诊断修复
- 作业开放生态
  - 可扩展的作业类型统一接口
  - 丰富的作业类型库，如数据流、脚本、HTTP、文件、大数据等
  - 易于对接业务作业，能够与 Spring 依赖注入无缝整合
- 可视化管控端
  - 作业管控端
  - 作业执行历史数据追踪
  - 注册中心管理



2. **Demo**

```java
    public void create(String jobName, String jobParameter, String cron) {
        logger.info("A elastic job is creating: {0}", jobParameter);
        EventBus.fireEvent(new Event(EventBus.ASYNC_EVENT, "CreateElasticjob: " + System.currentTimeMillis(), (Runnable) () -> {
            new ScheduleJobBootstrap(
                    registryCenter,
                    this,
                    JobConfiguration
                            .newBuilder(jobName, 1)
                            .jobParameter(jobParameter)
                            .overwrite(true)
                            .misfire(true)
                            .monitorExecution(true)
                            .failover(true)
                            .jobErrorHandlerType("IGNORE")
                            .cron(cron)
                            .build(),
                    tracingConfiguration
            ).schedule();
        }));
    }
    
        public void cancel(String jobName) {
        logger.info("A elastic job is cancelling: {0}", jobName);
        jobOperateAPI.disable(jobName, null);
        jobOperateAPI.remove(jobName, null);
        PKService.executor.schedule(() -> {
            //延迟再次结束任务, 因为quartz存在结束失败的情况.
            jobOperateAPI.remove(jobName, null);
            //延迟删除配置,避免调度过来时, 任务正好刚删除掉了配置, 导致的报错.
            jobConfigurationAPI.removeJobConfiguration(jobName);
        }, 3L, TimeUnit.SECONDS);
    }
```

3. **填坑.**

   1. yaml找不到问题.

   ```
   java.lang.NullPointerException: null
           at java.io.StringReader.<init>(StringReader.java:50) ~[?:1.8.0_261]
           at org.yaml.snakeyaml.reader.StreamReader.<init>(StreamReader.java:63) ~[snakeyaml-1.25.jar!/:?]
           at org.yaml.snakeyaml.Yaml.loadAs(Yaml.java:502) ~[snakeyaml-1.25.jar!/:?]
           at org.apache.shardingsphere.elasticjob.infra.yaml.YamlEngine.unmarshal(YamlEngine.java:49) ~[elasticjob-infra-common-3.0.0-alpha.jar!/:3.0.0-alpha]
           at org.apache.shardingsphere.elasticjob.lite.internal.config.ConfigurationService.load(ConfigurationService.java:59) ~[elasticjob-lite-core-3.0.0-alpha.jar!/:3.0.0-alpha]
           at org.apache.shardingsphere.elasticjob.lite.internal.config.ConfigurationService.checkMaxTimeDiffSecondsTolerable(ConfigurationService.java:96) ~[elasticjob-lite-core-3.0.0-alpha.jar!/:3.0.0-alpha]
           at org.apache.shardingsphere.elasticjob.lite.internal.schedule.LiteJobFacade.checkJobExecutionEnvironment(LiteJobFacade.java:81) ~[elasticjob-lite-core-3.0.0-alpha.jar!/:3.0.0-alpha]
           at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.execute(ElasticJobExecutor.java:85) ~[elasticjob-executor-kernel-3.0.0-alpha.jar!/:3.0.0-alpha]
           at org.apache.shardingsphere.elasticjob.lite.internal.schedule.LiteJob.execute(LiteJob.java:35) ~[elasticjob-lite-core-3.0.0-alpha.jar!/:3.0.0-alpha]
           at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.2.jar!/:?]
           at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) [quartz-2.3.2.jar!/:?]
   ```

   

   1. 当A,B两个任务同时开始调度,A任务通过API把两个任务都结束掉时,B任务可能会报错找不到yaml,因为被A删除掉了.

   解决: A任务延迟一点删除两个任务的yaml文件.

   2. 调用停止job后,输出结束成功,zk上配置也删除成功,但是本地任务一直在跑.

   解决: 结束一个job时,延时在进行第二次结束,确保完全结束.

   3. 开启任务失效转移,但是一个实例down掉后,定时任务没有转移到另一台机器.

   解决: 需要失效转移的任务,需要在每台实例都注册一次,这样才会当其中一台挂掉后,另一台自动接管.
